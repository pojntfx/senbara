// Package senbaragtkmeson was automatically generated by github.com/jwijenbergh/puregotk DO NOT EDIT
package senbaragtkmeson

import (
	"unsafe"

	"github.com/jwijenbergh/purego"
	"github.com/jwijenbergh/puregotk/pkg/core"
	"github.com/jwijenbergh/puregotk/v4/adw"
	"github.com/jwijenbergh/puregotk/v4/gdk"
	"github.com/jwijenbergh/puregotk/v4/gio"
	"github.com/jwijenbergh/puregotk/v4/glib"
	"github.com/jwijenbergh/puregotk/v4/gobject"
	"github.com/jwijenbergh/puregotk/v4/gobject/types"
	"github.com/jwijenbergh/puregotk/v4/gsk"
	"github.com/jwijenbergh/puregotk/v4/gtk"
)

// Example application window with a test button and toast notifications.
type MainApplicationWindow struct {
	adw.ApplicationWindow
}

var xMainApplicationWindowGLibType func() types.GType

func MainApplicationWindowGLibType() types.GType {
	return xMainApplicationWindowGLibType()
}

func MainApplicationWindowNewFromInternalPtr(ptr uintptr) *MainApplicationWindow {
	cls := &MainApplicationWindow{}
	cls.Ptr = ptr
	return cls
}

var xMainApplicationWindowShowToast func(uintptr, string)

// Shows a toast notification with the given message inside the window.
func (x *MainApplicationWindow) ShowToast(MessageVar string) {

	xMainApplicationWindowShowToast(x.GoPointer(), MessageVar)

}

func (c *MainApplicationWindow) GoPointer() uintptr {
	if c == nil {
		return 0
	}
	return c.Ptr
}

func (c *MainApplicationWindow) SetGoPointer(ptr uintptr) {
	c.Ptr = ptr
}

// SetPropertyTestButtonSensitive sets the "test-button-sensitive" property.
func (x *MainApplicationWindow) SetPropertyTestButtonSensitive(value bool) {
	var v gobject.Value
	v.Init(gobject.TypeBooleanVal)
	v.SetBoolean(value)
	x.SetProperty("test-button-sensitive", &v)
}

// GetPropertyTestButtonSensitive gets the "test-button-sensitive" property.
func (x *MainApplicationWindow) GetPropertyTestButtonSensitive() bool {
	var v gobject.Value
	x.GetProperty("test-button-sensitive", &v)
	return v.GetBoolean()
}

func (x *MainApplicationWindow) ConnectButtonTestClicked(cb *func(MainApplicationWindow)) uint32 {
	cbPtr := uintptr(unsafe.Pointer(cb))
	if cbRefPtr, ok := glib.GetCallback(cbPtr); ok {
		return gobject.SignalConnect(x.GoPointer(), "button-test-clicked", cbRefPtr)
	}

	fcb := func(clsPtr uintptr) {
		fa := MainApplicationWindow{}
		fa.Ptr = clsPtr
		cbFn := *cb

		cbFn(fa)

	}
	cbRefPtr := purego.NewCallback(fcb)
	glib.SaveCallback(cbPtr, cbRefPtr)
	return gobject.SignalConnect(x.GoPointer(), "button-test-clicked", cbRefPtr)
}

// Emits the [signal@Gio.ActionGroup::action-added] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *MainApplicationWindow) ActionAdded(ActionNameVar string) {

	gio.XGActionGroupActionAdded(x.GoPointer(), ActionNameVar)

}

// Emits the [signal@Gio.ActionGroup::action-enabled-changed] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *MainApplicationWindow) ActionEnabledChanged(ActionNameVar string, EnabledVar bool) {

	gio.XGActionGroupActionEnabledChanged(x.GoPointer(), ActionNameVar, EnabledVar)

}

// Emits the [signal@Gio.ActionGroup::action-removed] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *MainApplicationWindow) ActionRemoved(ActionNameVar string) {

	gio.XGActionGroupActionRemoved(x.GoPointer(), ActionNameVar)

}

// Emits the [signal@Gio.ActionGroup::action-state-changed] signal on @action_group.
//
// This function should only be called by [type@Gio.ActionGroup] implementations.
func (x *MainApplicationWindow) ActionStateChanged(ActionNameVar string, StateVar *glib.Variant) {

	gio.XGActionGroupActionStateChanged(x.GoPointer(), ActionNameVar, StateVar)

}

// Activate the named action within @action_group.
//
// If the action is expecting a parameter, then the correct type of
// parameter must be given as @parameter.  If the action is expecting no
// parameters then @parameter must be `NULL`.  See
// [method@Gio.ActionGroup.get_action_parameter_type].
//
// If the [type@Gio.ActionGroup] implementation supports asynchronous remote
// activation over D-Bus, this call may return before the relevant
// D-Bus traffic has been sent, or any replies have been received. In
// order to block on such asynchronous activation calls,
// [method@Gio.DBusConnection.flush] should be called prior to the code, which
// depends on the result of the action activation. Without flushing
// the D-Bus connection, there is no guarantee that the action would
// have been activated.
//
// The following code which runs in a remote app instance, shows an
// example of a ‘quit’ action being activated on the primary app
// instance over D-Bus. Here [method@Gio.DBusConnection.flush] is called
// before `exit()`. Without `g_dbus_connection_flush()`, the ‘quit’ action
// may fail to be activated on the primary instance.
//
// ```c
// // call ‘quit’ action on primary instance
// g_action_group_activate_action (G_ACTION_GROUP (app), "quit", NULL);
//
// // make sure the action is activated now
// g_dbus_connection_flush (…);
//
// g_debug ("Application has been terminated. Exiting.");
//
// exit (0);
// ```
func (x *MainApplicationWindow) ActivateAction(ActionNameVar string, ParameterVar *glib.Variant) {

	gio.XGActionGroupActivateAction(x.GoPointer(), ActionNameVar, ParameterVar)

}

// Request for the state of the named action within @action_group to be
// changed to @value.
//
// The action must be stateful and @value must be of the correct type.
// See [method@Gio.ActionGroup.get_action_state_type].
//
// This call merely requests a change.  The action may refuse to change
// its state or may change its state to something other than @value.
// See [method@Gio.ActionGroup.get_action_state_hint].
//
// If the @value GVariant is floating, it is consumed.
func (x *MainApplicationWindow) ChangeActionState(ActionNameVar string, ValueVar *glib.Variant) {

	gio.XGActionGroupChangeActionState(x.GoPointer(), ActionNameVar, ValueVar)

}

// Checks if the named action within @action_group is currently enabled.
//
// An action must be enabled in order to be activated or in order to
// have its state changed from outside callers.
func (x *MainApplicationWindow) GetActionEnabled(ActionNameVar string) bool {

	cret := gio.XGActionGroupGetActionEnabled(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the type of the parameter that must be given when activating
// the named action within @action_group.
//
// When activating the action using [method@Gio.ActionGroup.activate_action],
// the [type@GLib.Variant] given to that function must be of the type returned
// by this function.
//
// In the case that this function returns `NULL`, you must not give any
// [type@GLib.Variant], but `NULL` instead.
//
// The parameter type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different parameter type.
func (x *MainApplicationWindow) GetActionParameterType(ActionNameVar string) *glib.VariantType {

	cret := gio.XGActionGroupGetActionParameterType(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the current state of the named action within @action_group.
//
// If the action is not stateful then `NULL` will be returned.  If the
// action is stateful then the type of the return value is the type
// given by [method@Gio.ActionGroup.get_action_state_type].
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *MainApplicationWindow) GetActionState(ActionNameVar string) *glib.Variant {

	cret := gio.XGActionGroupGetActionState(x.GoPointer(), ActionNameVar)
	return cret
}

// Requests a hint about the valid range of values for the state of the
// named action within @action_group.
//
// If `NULL` is returned it either means that the action is not stateful
// or that there is no hint about the valid range of values for the
// state of the action.
//
// If a [type@GLib.Variant] array is returned then each item in the array is a
// possible value for the state.  If a [type@GLib.Variant] pair (ie: two-tuple) is
// returned then the tuple specifies the inclusive lower and upper bound
// of valid values for the state.
//
// In any case, the information is merely a hint.  It may be possible to
// have a state value outside of the hinted range and setting a value
// within the range may fail.
//
// The return value (if non-`NULL`) should be freed with
// [method@GLib.Variant.unref] when it is no longer required.
func (x *MainApplicationWindow) GetActionStateHint(ActionNameVar string) *glib.Variant {

	cret := gio.XGActionGroupGetActionStateHint(x.GoPointer(), ActionNameVar)
	return cret
}

// Queries the type of the state of the named action within
// @action_group.
//
// If the action is stateful then this function returns the
// [type@GLib.VariantType] of the state.  All calls to
// [method@Gio.ActionGroup.change_action_state] must give a [type@GLib.Variant] of this
// type and [method@Gio.ActionGroup.get_action_state] will return a [type@GLib.Variant]
// of the same type.
//
// If the action is not stateful then this function will return `NULL`.
// In that case, [method@Gio.ActionGroup.get_action_state] will return `NULL`
// and you must not call [method@Gio.ActionGroup.change_action_state].
//
// The state type of a particular action will never change but it is
// possible for an action to be removed and for a new action to be added
// with the same name but a different state type.
func (x *MainApplicationWindow) GetActionStateType(ActionNameVar string) *glib.VariantType {

	cret := gio.XGActionGroupGetActionStateType(x.GoPointer(), ActionNameVar)
	return cret
}

// Checks if the named action exists within @action_group.
func (x *MainApplicationWindow) HasAction(ActionNameVar string) bool {

	cret := gio.XGActionGroupHasAction(x.GoPointer(), ActionNameVar)
	return cret
}

// Lists the actions contained within @action_group.
//
// The caller is responsible for freeing the list with [func@GLib.strfreev] when
// it is no longer required.
func (x *MainApplicationWindow) ListActions() []string {

	cret := gio.XGActionGroupListActions(x.GoPointer())
	return cret
}

// Queries all aspects of the named action within an @action_group.
//
// This function acquires the information available from
// [method@Gio.ActionGroup.has_action], [method@Gio.ActionGroup.get_action_enabled],
// [method@Gio.ActionGroup.get_action_parameter_type],
// [method@Gio.ActionGroup.get_action_state_type],
// [method@Gio.ActionGroup.get_action_state_hint] and
// [method@Gio.ActionGroup.get_action_state] with a single function call.
//
// This provides two main benefits.
//
// The first is the improvement in efficiency that comes with not having
// to perform repeated lookups of the action in order to discover
// different things about it.  The second is that implementing
// [type@Gio.ActionGroup] can now be done by only overriding this one virtual
// function.
//
// The interface provides a default implementation of this function that
// calls the individual functions, as required, to fetch the
// information.  The interface also provides default implementations of
// those functions that call this function.  All implementations,
// therefore, must override either this function or all of the others.
//
// If the action exists, `TRUE` is returned and any of the requested
// fields (as indicated by having a non-`NULL` reference passed in) are
// filled.  If the action doesn’t exist, `FALSE` is returned and the
// fields may or may not have been modified.
func (x *MainApplicationWindow) QueryAction(ActionNameVar string, EnabledVar *bool, ParameterTypeVar **glib.VariantType, StateTypeVar **glib.VariantType, StateHintVar **glib.Variant, StateVar **glib.Variant) bool {

	cret := gio.XGActionGroupQueryAction(x.GoPointer(), ActionNameVar, EnabledVar, ParameterTypeVar, StateTypeVar, StateHintVar, StateVar)
	return cret
}

// Adds an action to the @action_map.
//
// If the action map already contains an action with the same name
// as @action then the old action is dropped from the action map.
//
// The action map takes its own reference on @action.
func (x *MainApplicationWindow) AddAction(ActionVar gio.Action) {

	gio.XGActionMapAddAction(x.GoPointer(), ActionVar.GoPointer())

}

// A convenience function for creating multiple [class@Gio.SimpleAction]
// instances and adding them to a [iface@Gio.ActionMap].
//
// Each action is constructed as per one [struct@Gio.ActionEntry].
//
// ```c
// static void
// activate_quit (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  exit (0);
//	}
//
// static void
// activate_print_string (GSimpleAction *simple,
//
//	GVariant      *parameter,
//	gpointer       user_data)
//
//	{
//	  g_print ("%s\n", g_variant_get_string (parameter, NULL));
//	}
//
// static GActionGroup *
// create_action_group (void)
//
//	{
//	  const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	  };
//	  GSimpleActionGroup *group;
//
//	  group = g_simple_action_group_new ();
//	  g_action_map_add_action_entries (G_ACTION_MAP (group), entries, G_N_ELEMENTS (entries), NULL);
//
//	  return G_ACTION_GROUP (group);
//	}
//
// ```
func (x *MainApplicationWindow) AddActionEntries(EntriesVar []gio.ActionEntry, NEntriesVar int, UserDataVar uintptr) {

	gio.XGActionMapAddActionEntries(x.GoPointer(), EntriesVar, NEntriesVar, UserDataVar)

}

// Looks up the action with the name @action_name in @action_map.
//
// If no such action exists, returns `NULL`.
func (x *MainApplicationWindow) LookupAction(ActionNameVar string) *gio.ActionBase {
	var cls *gio.ActionBase

	cret := gio.XGActionMapLookupAction(x.GoPointer(), ActionNameVar)

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gio.ActionBase{}
	cls.Ptr = cret
	return cls
}

// Removes the named action from the action map.
//
// If no action of this name is in the map then nothing happens.
func (x *MainApplicationWindow) RemoveAction(ActionNameVar string) {

	gio.XGActionMapRemoveAction(x.GoPointer(), ActionNameVar)

}

// Remove actions from a [iface@Gio.ActionMap]. This is meant as the reverse of
// [method@Gio.ActionMap.add_action_entries].
//
// ```c
//
//	static const GActionEntry entries[] = {
//	    { "quit",         activate_quit              },
//	    { "print-string", activate_print_string, "s" }
//	};
//
// void
// add_actions (GActionMap *map)
//
//	{
//	  g_action_map_add_action_entries (map, entries, G_N_ELEMENTS (entries), NULL);
//	}
//
// void
// remove_actions (GActionMap *map)
//
//	{
//	  g_action_map_remove_action_entries (map, entries, G_N_ELEMENTS (entries));
//	}
//
// ```
func (x *MainApplicationWindow) RemoveActionEntries(EntriesVar []gio.ActionEntry, NEntriesVar int) {

	gio.XGActionMapRemoveActionEntries(x.GoPointer(), EntriesVar, NEntriesVar)

}

// Requests the user's screen reader to announce the given message.
//
// This kind of notification is useful for messages that
// either have only a visual representation or that are not
// exposed visually at all, e.g. a notification about a
// successful operation.
//
// Also, by using this API, you can ensure that the message
// does not interrupts the user's current screen reader output.
func (x *MainApplicationWindow) Announce(MessageVar string, PriorityVar gtk.AccessibleAnnouncementPriority) {

	gtk.XGtkAccessibleAnnounce(x.GoPointer(), MessageVar, PriorityVar)

}

// Retrieves the accessible parent for an accessible object.
//
// This function returns `NULL` for top level widgets.
func (x *MainApplicationWindow) GetAccessibleParent() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetAccessibleParent(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the accessible role of an accessible object.
func (x *MainApplicationWindow) GetAccessibleRole() gtk.AccessibleRole {

	cret := gtk.XGtkAccessibleGetAccessibleRole(x.GoPointer())
	return cret
}

// Retrieves the implementation for the given accessible object.
func (x *MainApplicationWindow) GetAtContext() *gtk.ATContext {
	var cls *gtk.ATContext

	cret := gtk.XGtkAccessibleGetAtContext(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.ATContext{}
	cls.Ptr = cret
	return cls
}

// Queries the coordinates and dimensions of this accessible
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get the bounds from an ignored
// child widget.
func (x *MainApplicationWindow) GetBounds(XVar *int, YVar *int, WidthVar *int, HeightVar *int) bool {

	cret := gtk.XGtkAccessibleGetBounds(x.GoPointer(), XVar, YVar, WidthVar, HeightVar)
	return cret
}

// Retrieves the first accessible child of an accessible object.
func (x *MainApplicationWindow) GetFirstAccessibleChild() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetFirstAccessibleChild(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Retrieves the next accessible sibling of an accessible object
func (x *MainApplicationWindow) GetNextAccessibleSibling() *gtk.AccessibleBase {
	var cls *gtk.AccessibleBase

	cret := gtk.XGtkAccessibleGetNextAccessibleSibling(x.GoPointer())

	if cret == 0 {
		return nil
	}
	cls = &gtk.AccessibleBase{}
	cls.Ptr = cret
	return cls
}

// Queries a platform state, such as focus.
//
// This functionality can be overridden by `GtkAccessible`
// implementations, e.g. to get platform state from an ignored
// child widget, as is the case for `GtkText` wrappers.
func (x *MainApplicationWindow) GetPlatformState(StateVar gtk.AccessiblePlatformState) bool {

	cret := gtk.XGtkAccessibleGetPlatformState(x.GoPointer(), StateVar)
	return cret
}

// Resets the accessible property to its default value.
func (x *MainApplicationWindow) ResetProperty(PropertyVar gtk.AccessibleProperty) {

	gtk.XGtkAccessibleResetProperty(x.GoPointer(), PropertyVar)

}

// Resets the accessible relation to its default value.
func (x *MainApplicationWindow) ResetRelation(RelationVar gtk.AccessibleRelation) {

	gtk.XGtkAccessibleResetRelation(x.GoPointer(), RelationVar)

}

// Resets the accessible state to its default value.
func (x *MainApplicationWindow) ResetState(StateVar gtk.AccessibleState) {

	gtk.XGtkAccessibleResetState(x.GoPointer(), StateVar)

}

// Sets the parent and sibling of an accessible object.
//
// This function is meant to be used by accessible implementations that are
// not part of the widget hierarchy, and but act as a logical bridge between
// widgets. For instance, if a widget creates an object that holds metadata
// for each child, and you want that object to implement the `GtkAccessible`
// interface, you will use this function to ensure that the parent of each
// child widget is the metadata object, and the parent of each metadata
// object is the container widget.
func (x *MainApplicationWindow) SetAccessibleParent(ParentVar gtk.Accessible, NextSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleSetAccessibleParent(x.GoPointer(), ParentVar.GoPointer(), NextSiblingVar.GoPointer())

}

// Updates the next accessible sibling.
//
// That might be useful when a new child of a custom accessible
// is created, and it needs to be linked to a previous child.
func (x *MainApplicationWindow) UpdateNextAccessibleSibling(NewSiblingVar gtk.Accessible) {

	gtk.XGtkAccessibleUpdateNextAccessibleSibling(x.GoPointer(), NewSiblingVar.GoPointer())

}

// Informs ATs that the platform state has changed.
//
// This function should be used by `GtkAccessible` implementations that
// have a platform state but are not widgets. Widgets handle platform
// states automatically.
func (x *MainApplicationWindow) UpdatePlatformState(StateVar gtk.AccessiblePlatformState) {

	gtk.XGtkAccessibleUpdatePlatformState(x.GoPointer(), StateVar)

}

// Updates a list of accessible properties.
//
// See the [enum@Gtk.AccessibleProperty] documentation for the
// value types of accessible properties.
//
// This function should be called by `GtkWidget` types whenever
// an accessible property change must be communicated to assistive
// technologies.
//
// Example:
// ```c
// value = gtk_adjustment_get_value (adjustment);
// gtk_accessible_update_property (GTK_ACCESSIBLE (spin_button),
//
//	GTK_ACCESSIBLE_PROPERTY_VALUE_NOW, value,
//	-1);
//
// ```
func (x *MainApplicationWindow) UpdateProperty(FirstPropertyVar gtk.AccessibleProperty, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateProperty(x.GoPointer(), FirstPropertyVar, varArgs...)

}

// Updates an array of accessible properties.
//
// This function should be called by `GtkWidget` types whenever an accessible
// property change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MainApplicationWindow) UpdatePropertyValue(NPropertiesVar int, PropertiesVar []gtk.AccessibleProperty, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdatePropertyValue(x.GoPointer(), NPropertiesVar, PropertiesVar, ValuesVar)

}

// Updates a list of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// If the [enum@Gtk.AccessibleRelation] requires a list of references,
// you should pass each reference individually, followed by `NULL`, e.g.
//
// ```c
// gtk_accessible_update_relation (accessible,
//
//	GTK_ACCESSIBLE_RELATION_CONTROLS,
//	  ref1, NULL,
//	GTK_ACCESSIBLE_RELATION_LABELLED_BY,
//	  ref1, ref2, ref3, NULL,
//	-1);
//
// ```
func (x *MainApplicationWindow) UpdateRelation(FirstRelationVar gtk.AccessibleRelation, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateRelation(x.GoPointer(), FirstRelationVar, varArgs...)

}

// Updates an array of accessible relations.
//
// This function should be called by `GtkWidget` types whenever an accessible
// relation change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MainApplicationWindow) UpdateRelationValue(NRelationsVar int, RelationsVar []gtk.AccessibleRelation, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateRelationValue(x.GoPointer(), NRelationsVar, RelationsVar, ValuesVar)

}

// Updates a list of accessible states.
//
// See the [enum@Gtk.AccessibleState] documentation for the
// value types of accessible states.
//
// This function should be called by `GtkWidget` types whenever
// an accessible state change must be communicated to assistive
// technologies.
//
// Example:
//
// ```c
// value = GTK_ACCESSIBLE_TRISTATE_MIXED;
// gtk_accessible_update_state (GTK_ACCESSIBLE (check_button),
//
//	GTK_ACCESSIBLE_STATE_CHECKED, value,
//	-1);
//
// ```
func (x *MainApplicationWindow) UpdateState(FirstStateVar gtk.AccessibleState, varArgs ...interface{}) {

	gtk.XGtkAccessibleUpdateState(x.GoPointer(), FirstStateVar, varArgs...)

}

// Updates an array of accessible states.
//
// This function should be called by `GtkWidget` types whenever an accessible
// state change must be communicated to assistive technologies.
//
// This function is meant to be used by language bindings.
func (x *MainApplicationWindow) UpdateStateValue(NStatesVar int, StatesVar []gtk.AccessibleState, ValuesVar []gobject.Value) {

	gtk.XGtkAccessibleUpdateStateValue(x.GoPointer(), NStatesVar, StatesVar, ValuesVar)

}

// Gets the ID of the @buildable object.
//
// `GtkBuilder` sets the name based on the ID attribute
// of the `&lt;object&gt;` tag used to construct the @buildable.
func (x *MainApplicationWindow) GetBuildableId() string {

	cret := gtk.XGtkBuildableGetBuildableId(x.GoPointer())
	return cret
}

// Returns the renderer that is used for this `GtkNative`.
func (x *MainApplicationWindow) GetRenderer() *gsk.Renderer {
	var cls *gsk.Renderer

	cret := gtk.XGtkNativeGetRenderer(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gsk.Renderer{}
	cls.Ptr = cret
	return cls
}

// Returns the surface of this `GtkNative`.
func (x *MainApplicationWindow) GetSurface() *gdk.Surface {
	var cls *gdk.Surface

	cret := gtk.XGtkNativeGetSurface(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Surface{}
	cls.Ptr = cret
	return cls
}

// Retrieves the surface transform of @self.
//
// This is the translation from @self's surface coordinates into
// @self's widget coordinates.
func (x *MainApplicationWindow) GetSurfaceTransform(XVar *float64, YVar *float64) {

	gtk.XGtkNativeGetSurfaceTransform(x.GoPointer(), XVar, YVar)

}

// Realizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *MainApplicationWindow) Realize() {

	gtk.XGtkNativeRealize(x.GoPointer())

}

// Unrealizes a `GtkNative`.
//
// This should only be used by subclasses.
func (x *MainApplicationWindow) Unrealize() {

	gtk.XGtkNativeUnrealize(x.GoPointer())

}

// Returns the display that this `GtkRoot` is on.
func (x *MainApplicationWindow) GetDisplay() *gdk.Display {
	var cls *gdk.Display

	cret := gtk.XGtkRootGetDisplay(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gdk.Display{}
	cls.Ptr = cret
	return cls
}

// Retrieves the current focused widget within the root.
//
// Note that this is the widget that would have the focus
// if the root is active; if the root is not focused then
// `gtk_widget_has_focus (widget)` will be %FALSE for the
// widget.
func (x *MainApplicationWindow) GetFocus() *gtk.Widget {
	var cls *gtk.Widget

	cret := gtk.XGtkRootGetFocus(x.GoPointer())

	if cret == 0 {
		return nil
	}
	gobject.IncreaseRef(cret)
	cls = &gtk.Widget{}
	cls.Ptr = cret
	return cls
}

// If @focus is not the current focus widget, and is focusable, sets
// it as the focus widget for the root.
//
// If @focus is %NULL, unsets the focus widget for the root.
//
// To set the focus to a particular widget in the root, it is usually
// more convenient to use [method@Gtk.Widget.grab_focus] instead of
// this function.
func (x *MainApplicationWindow) SetFocus(FocusVar *gtk.Widget) {

	gtk.XGtkRootSetFocus(x.GoPointer(), FocusVar.GoPointer())

}

func init() {
	core.SetPackageName("SENBARAGTKMESON", "senbara-gtk-meson-0.1")
	core.SetSharedLibraries("SENBARAGTKMESON", []string{"libsenbara-gtk-meson-0.1.so"})
	var libs []uintptr
	for _, libPath := range core.GetPaths("SENBARAGTKMESON") {
		lib, err := purego.Dlopen(libPath, purego.RTLD_NOW|purego.RTLD_GLOBAL)
		if err != nil {
			panic(err)
		}
		libs = append(libs, lib)
	}

	core.PuregoSafeRegister(&xMainApplicationWindowGLibType, libs, "senbara_gtk_meson_main_application_window_get_type")

	core.PuregoSafeRegister(&xMainApplicationWindowShowToast, libs, "senbara_gtk_meson_main_application_window_show_toast")

}
